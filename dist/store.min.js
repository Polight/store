class t{actions={};#t={};constructor(t={},s={}){this.#t=t,Object.keys(s).map((t=>this.addAction(t,s[t]))),this.subscribers=[]}addAction(t,s){this.actions[t]=s.bind(this)}subscribe(t,s=[]){this.subscribers.push({target:t,props:this.propsNames(s)})}get state(){return this.#t}setState(t){this.#t={...this.#t,...t},this.notify()}getSelectedState(t=[]){return t.reduce(((t,s)=>(s in this.#t&&(t[s]=this.#t[s]),t)),{})}propsNames(t){return Array.isArray(t)?t:Object.keys(t)}notify(){this.subscribers.forEach((({target:t,props:s})=>{this.notifyCall(t,this.getSelectedState(s)),t.render(this.getSelectedState(s))}))}notifyCall(t,s){throw new Error("notifyCall() is not implemented!")}dispatch(t,...s){const e=this.actions[t];if(!e)throw new Error(`action "${t}" does not exist!`);e(...s)}}class s extends t{subscribe(t,s=[]){super.subscribe(t,s),t.setState(this.getSelectedState(this.propsNames(s)))}notifyCall(t,s){t.render(s)}}export{t as AbstractStore,s as LegoStore};
