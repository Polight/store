class t{constructor(t={},s={}){this._state=t,this.actions=[],Object.keys(s).map((t=>this.addAction(t,s[t]))),this.subscribers=[]}addAction(t,s){this.actions[t]=s.bind(this)}subscribe(t,s=[]){const e=Array.isArray(s)?s:Object.keys(s);this.subscribers.push({target:t,props:e})}get state(){return this._state}setState(t){this._state={...this.state,...t},this.notify()}getSelectedState(t){return t.reduce(((t,s)=>(s in this.state&&(t[s]=this.state[s]),t)),{})}notify(){this.subscribers.forEach((({target:t,props:s})=>{this.notifyCall(t,this.getSelectedState(s)),t.render(this.getSelectedState(s))}))}notifyCall(t,s){throw new Error("notifyCall() is not implemented!")}dispatch(t,...s){const e=this._actions[t];if(!e)throw new Error(`action "${t}" does not exist!`);e(...s)}}class s extends t{subscribe(t,s=[]){super.subscribe(t,s),t.setState(this.getSelectedState(s))}notifyCall(t,s){t.render(s)}}export{t as AbstractStore,s as LegoStore};
